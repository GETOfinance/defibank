// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract ProtectedPay {
  enum TransferStatus{Pending,Claimed,Refunded} enum GroupPaymentStatus{Pending,Completed} enum PotStatus{Active,Broken}
  struct Transfer{address sender;address recipient;uint256 amount;uint256 timestamp;TransferStatus status;string remarks;}
  struct GroupPayment{bytes32 paymentId;address creator;address recipient;uint256 totalAmount;uint256 amountPerPerson;uint256 numParticipants;uint256 amountCollected;uint256 timestamp;string remarks;GroupPaymentStatus status;}
  struct SavingsPot{bytes32 potId;address owner;string name;uint256 targetAmount;uint256 currentAmount;uint256 timestamp;string remarks;PotStatus status;}
  struct User{string username;}
  mapping(bytes32=>Transfer)public transfers; mapping(address=>bytes32[])public pendingTransfersBySender; mapping(bytes32=>GroupPayment)public groupPayments; mapping(bytes32=>mapping(address=>uint256))public groupPaymentContributions; mapping(bytes32=>SavingsPot)public savingsPots; mapping(address=>User)public users; mapping(string=>address)public usernameToAddress; mapping(address=>bytes32[])private userTransferIds; mapping(address=>bytes32[])private userGroupPaymentIds; mapping(address=>bytes32[])private userParticipatedGroupPayments; mapping(address=>bytes32[])private userSavingsPotIds;
  event TransferInitiated(bytes32 indexed transferId,address indexed sender,address indexed recipient,uint256 amount,string remarks); event TransferClaimed(bytes32 indexed transferId,address indexed recipient,uint256 amount); event TransferRefunded(bytes32 indexed transferId,address indexed sender,uint256 amount); event GroupPaymentCreated(bytes32 indexed paymentId,address indexed creator,address recipient,uint256 totalAmount,uint256 numParticipants,string remarks); event GroupPaymentContributed(bytes32 indexed paymentId,address indexed contributor,uint256 amount); event GroupPaymentCompleted(bytes32 indexed paymentId,address indexed recipient,uint256 amount); event SavingsPotCreated(bytes32 indexed potId,address indexed owner,string name,uint256 targetAmount,string remarks); event PotContribution(bytes32 indexed potId,address indexed contributor,uint256 amount); event PotBroken(bytes32 indexed potId,address indexed owner,uint256 amount); event UserRegistered(address indexed userAddress,string username);
  // usernames
  function registerUsername(string memory u) external {require(bytes(u).length>0,"empty username"); address ex=usernameToAddress[u]; require(ex==address(0)||ex==msg.sender,"taken"); string memory old=users[msg.sender].username; if(bytes(old).length>0&&keccak256(bytes(old))!=keccak256(bytes(u))){usernameToAddress[old]=address(0);} users[msg.sender].username=u; usernameToAddress[u]=msg.sender; emit UserRegistered(msg.sender,u);}
  function getUserByAddress(address a) external view returns(string memory){return users[a].username;} function getUserByUsername(string memory u) external view returns(address){return usernameToAddress[u];}
  // transfers
  function _newTransferId(address s,address r,uint256 amt,string memory rem) internal view returns(bytes32){return keccak256(abi.encodePacked(s,r,amt,rem,block.timestamp,block.prevrandao));}
  function sendToAddress(address r,string calldata rem) public payable {require(r!=address(0),"bad recipient"); require(msg.value>0,"no value"); bytes32 id=_newTransferId(msg.sender,r,msg.value,rem); transfers[id]=Transfer({sender:msg.sender,recipient:r,amount:msg.value,timestamp:block.timestamp,status:TransferStatus.Pending,remarks:rem}); pendingTransfersBySender[msg.sender].push(id); userTransferIds[msg.sender].push(id); emit TransferInitiated(id,msg.sender,r,msg.value,rem);}
  function sendToUsername(string calldata u,string calldata rem) external payable {address r=usernameToAddress[u]; require(r!=address(0),"unknown user"); sendToAddress(r,rem);}
  function getPendingTransfers(address s) external view returns(bytes32[] memory){return pendingTransfersBySender[s];}
  function getTransferDetails(bytes32 id) external view returns(address,address,uint256,uint256,TransferStatus,string memory){Transfer storage t=transfers[id]; return(t.sender,t.recipient,t.amount,t.timestamp,t.status,t.remarks);}
  function claimTransferById(bytes32 id) public {Transfer storage t=transfers[id]; require(t.status==TransferStatus.Pending,"not pending"); require(msg.sender==t.recipient,"not recipient"); t.status=TransferStatus.Claimed; uint256 amt=t.amount; t.amount=0; (bool ok,)=t.recipient.call{value:amt}(""); require(ok,"transfer fail"); emit TransferClaimed(id,t.recipient,amt);}
  function claimTransferByAddress(address s) external {bytes32[] storage ids=pendingTransfersBySender[s]; for(uint256 i=0;i<ids.length;i++){Transfer storage t=transfers[ids[i]]; if(t.status==TransferStatus.Pending&&t.recipient==msg.sender){claimTransferById(ids[i]); return;}} revert("no pending transfer");}
  function claimTransferByUsername(string calldata su) external {address s=usernameToAddress[su]; require(s!=address(0),"unknown sender"); this.claimTransferByAddress(s);}
  function refundTransfer(bytes32 id) external {Transfer storage t=transfers[id]; require(t.status==TransferStatus.Pending,"not pending"); require(msg.sender==t.sender,"not sender"); t.status=TransferStatus.Refunded; uint256 amt=t.amount; t.amount=0; (bool ok,)=t.sender.call{value:amt}(""); require(ok,"refund fail"); emit TransferRefunded(id,t.sender,amt);}
  // group payments
  function createGroupPayment(address r,uint256 n,string calldata rem) external payable {require(r!=address(0),"bad recipient"); require(n>0,"num=0"); require(msg.value>0,"no value"); bytes32 id=keccak256(abi.encodePacked(msg.sender,r,msg.value,n,rem,block.timestamp,block.prevrandao)); uint256 per=msg.value/n; groupPayments[id]=GroupPayment({paymentId:id,creator:msg.sender,recipient:r,totalAmount:msg.value,amountPerPerson:per,numParticipants:n,amountCollected:0,timestamp:block.timestamp,remarks:rem,status:GroupPaymentStatus.Pending}); userGroupPaymentIds[msg.sender].push(id); emit GroupPaymentCreated(id,msg.sender,r,msg.value,n,rem);}
  function contributeToGroupPayment(bytes32 id) external payable {GroupPayment storage gp=groupPayments[id]; require(gp.creator!=address(0),"no payment"); require(gp.status==GroupPaymentStatus.Pending,"done"); require(msg.value>0,"no value"); groupPaymentContributions[id][msg.sender]+=msg.value; gp.amountCollected+=msg.value; userParticipatedGroupPayments[msg.sender].push(id); emit GroupPaymentContributed(id,msg.sender,msg.value); if(gp.amountCollected>=gp.totalAmount){gp.status=GroupPaymentStatus.Completed; uint256 amt=gp.amountCollected; gp.amountCollected=0; (bool ok,)=gp.recipient.call{value:amt}(""); require(ok,"pay fail"); emit GroupPaymentCompleted(id,gp.recipient,amt);} }
  function getGroupPaymentContribution(bytes32 id,address u) external view returns(uint256){return groupPaymentContributions[id][u];}
  function hasContributedToGroupPayment(bytes32 id,address u) external view returns(bool){return groupPaymentContributions[id][u]>0;}
  function getGroupPaymentDetails(bytes32 id) external view returns(address,address,uint256,uint256,uint256,uint256,uint256,GroupPaymentStatus,string memory){GroupPayment storage gp=groupPayments[id]; return(gp.creator,gp.recipient,gp.totalAmount,gp.amountPerPerson,gp.numParticipants,gp.amountCollected,gp.timestamp,gp.status,gp.remarks);}
  // savings
  function createSavingsPot(string calldata name,uint256 target,string calldata rem) external returns(bytes32){require(bytes(name).length>0,"empty name"); bytes32 id=keccak256(abi.encodePacked(msg.sender,name,target,rem,block.timestamp,block.prevrandao)); savingsPots[id]=SavingsPot({potId:id,owner:msg.sender,name:name,targetAmount:target,currentAmount:0,timestamp:block.timestamp,remarks:rem,status:PotStatus.Active}); userSavingsPotIds[msg.sender].push(id); emit SavingsPotCreated(id,msg.sender,name,target,rem); return id;}
  function contributeToSavingsPot(bytes32 id) external payable {SavingsPot storage p=savingsPots[id]; require(p.owner!=address(0),"no pot"); require(p.status==PotStatus.Active,"not active"); require(msg.value>0,"no value"); p.currentAmount+=msg.value; emit PotContribution(id,msg.sender,msg.value);}
  function getSavingsPotDetails(bytes32 id) external view returns(address,string memory,uint256,uint256,uint256,PotStatus,string memory){SavingsPot storage p=savingsPots[id]; return(p.owner,p.name,p.targetAmount,p.currentAmount,p.timestamp,p.status,p.remarks);}
  function breakPot(bytes32 id) external {SavingsPot storage p=savingsPots[id]; require(p.owner==msg.sender,"not owner"); require(p.status==PotStatus.Active,"not active"); p.status=PotStatus.Broken; uint256 amt=p.currentAmount; p.currentAmount=0; (bool ok,)=msg.sender.call{value:amt}(""); require(ok,"withdraw fail"); emit PotBroken(id,msg.sender,amt);}
  // profile
  function getUserProfile(address u) external view returns(string memory,bytes32[] memory,bytes32[] memory,bytes32[] memory,bytes32[] memory){return(users[u].username,userTransferIds[u],userGroupPaymentIds[u],userParticipatedGroupPayments[u],userSavingsPotIds[u]);}
  function getUserTransfers(address u) external view returns(Transfer[] memory){bytes32[] storage ids=userTransferIds[u]; Transfer[] memory arr=new Transfer[](ids.length); for(uint256 i=0;i<ids.length;i++){arr[i]=transfers[ids[i]];} return arr;}
}

